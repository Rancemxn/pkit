--- a/setup.py	2023-08-29 19:00:29.000000000 +0800
+++ b/setup.py	2025-05-11 12:10:41.975104600 +0800
@@ -1,292 +1,299 @@
-# Copyright 2015 The Brotli Authors. All rights reserved.
-#
-# Distributed under MIT license.
-# See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
-
-import os
-import platform
-import re
-import unittest
-
-try:
-    from setuptools import Extension
-    from setuptools import setup
-except:
-    from distutils.core import Extension
-    from distutils.core import setup
-from distutils.command.build_ext import build_ext
-from distutils import errors
-from distutils import dep_util
-from distutils import log
-
-
-CURR_DIR = os.path.abspath(os.path.dirname(os.path.realpath(__file__)))
-
-
-def read_define(path, macro):
-  """ Return macro value from the given file. """
-  with open(path, 'r') as f:
-    for line in f:
-      m = re.match(rf'#define\s{macro}\s+(.+)', line)
-      if m:
-        return m.group(1)
-  return ''
-
-
-def get_version():
-  """ Return library version string from 'common/version.h' file. """
-  version_file_path = os.path.join(CURR_DIR, 'c', 'common', 'version.h')
-  major = read_define(version_file_path, 'BROTLI_VERSION_MAJOR')
-  minor = read_define(version_file_path, 'BROTLI_VERSION_MINOR')
-  patch = read_define(version_file_path, 'BROTLI_VERSION_PATCH')
-  if not major or not minor or not patch:
-    return ''
-  return f'{major}.{minor}.{patch}'
-
-
-def get_test_suite():
-  test_loader = unittest.TestLoader()
-  test_suite = test_loader.discover('python', pattern='*_test.py')
-  return test_suite
-
-
-class BuildExt(build_ext):
-
-  def get_source_files(self):
-    filenames = build_ext.get_source_files(self)
-    for ext in self.extensions:
-      filenames.extend(ext.depends)
-    return filenames
-
-  def build_extension(self, ext):
-    if ext.sources is None or not isinstance(ext.sources, (list, tuple)):
-      raise errors.DistutilsSetupError(
-        "in 'ext_modules' option (extension '%s'), "
-        "'sources' must be present and must be "
-        "a list of source filenames" % ext.name)
-
-    ext_path = self.get_ext_fullpath(ext.name)
-    depends = ext.sources + ext.depends
-    if not (self.force or dep_util.newer_group(depends, ext_path, 'newer')):
-      log.debug("skipping '%s' extension (up-to-date)", ext.name)
-      return
-    else:
-      log.info("building '%s' extension", ext.name)
-
-    c_sources = []
-    for source in ext.sources:
-      if source.endswith('.c'):
-        c_sources.append(source)
-    extra_args = ext.extra_compile_args or []
-
-    objects = []
-
-    macros = ext.define_macros[:]
-    if platform.system() == 'Darwin':
-      macros.append(('OS_MACOSX', '1'))
-    elif self.compiler.compiler_type == 'mingw32':
-      # On Windows Python 2.7, pyconfig.h defines "hypot" as "_hypot",
-      # This clashes with GCC's cmath, and causes compilation errors when
-      # building under MinGW: http://bugs.python.org/issue11566
-      macros.append(('_hypot', 'hypot'))
-    for undef in ext.undef_macros:
-      macros.append((undef,))
-
-    objs = self.compiler.compile(
-        c_sources,
-        output_dir=self.build_temp,
-        macros=macros,
-        include_dirs=ext.include_dirs,
-        debug=self.debug,
-        extra_postargs=extra_args,
-        depends=ext.depends)
-    objects.extend(objs)
-
-    self._built_objects = objects[:]
-    if ext.extra_objects:
-      objects.extend(ext.extra_objects)
-    extra_args = ext.extra_link_args or []
-    # when using GCC on Windows, we statically link libgcc and libstdc++,
-    # so that we don't need to package extra DLLs
-    if self.compiler.compiler_type == 'mingw32':
-        extra_args.extend(['-static-libgcc', '-static-libstdc++'])
-
-    ext_path = self.get_ext_fullpath(ext.name)
-    # Detect target language, if not provided
-    language = ext.language or self.compiler.detect_language(c_sources)
-
-    self.compiler.link_shared_object(
-        objects,
-        ext_path,
-        libraries=self.get_libraries(ext),
-        library_dirs=ext.library_dirs,
-        runtime_library_dirs=ext.runtime_library_dirs,
-        extra_postargs=extra_args,
-        export_symbols=self.get_export_symbols(ext),
-        debug=self.debug,
-        build_temp=self.build_temp,
-        target_lang=language)
-
-
-NAME = 'Brotli'
-
-VERSION = get_version()
-
-URL = 'https://github.com/google/brotli'
-
-DESCRIPTION = 'Python bindings for the Brotli compression library'
-
-AUTHOR = 'The Brotli Authors'
-
-LICENSE = 'MIT'
-
-PLATFORMS = ['Posix', 'MacOS X', 'Windows']
-
-CLASSIFIERS = [
-    'Development Status :: 4 - Beta',
-    'Environment :: Console',
-    'Intended Audience :: Developers',
-    'License :: OSI Approved :: MIT License',
-    'Operating System :: MacOS :: MacOS X',
-    'Operating System :: Microsoft :: Windows',
-    'Operating System :: POSIX :: Linux',
-    'Programming Language :: C',
-    'Programming Language :: C++',
-    'Programming Language :: Python',
-    'Programming Language :: Python :: 2',
-    'Programming Language :: Python :: 2.7',
-    'Programming Language :: Python :: 3',
-    'Programming Language :: Python :: 3.3',
-    'Programming Language :: Python :: 3.4',
-    'Programming Language :: Python :: 3.5',
-    'Programming Language :: Unix Shell',
-    'Topic :: Software Development :: Libraries',
-    'Topic :: Software Development :: Libraries :: Python Modules',
-    'Topic :: System :: Archiving',
-    'Topic :: System :: Archiving :: Compression',
-    'Topic :: Text Processing :: Fonts',
-    'Topic :: Utilities',
-]
-
-PACKAGE_DIR = {'': 'python'}
-
-PY_MODULES = ['brotli']
-
-EXT_MODULES = [
-    Extension(
-        '_brotli',
-        sources=[
-            'python/_brotli.c',
-            'c/common/constants.c',
-            'c/common/context.c',
-            'c/common/dictionary.c',
-            'c/common/platform.c',
-            'c/common/shared_dictionary.c',
-            'c/common/transform.c',
-            'c/dec/bit_reader.c',
-            'c/dec/decode.c',
-            'c/dec/huffman.c',
-            'c/dec/state.c',
-            'c/enc/backward_references.c',
-            'c/enc/backward_references_hq.c',
-            'c/enc/bit_cost.c',
-            'c/enc/block_splitter.c',
-            'c/enc/brotli_bit_stream.c',
-            'c/enc/cluster.c',
-            'c/enc/command.c',
-            'c/enc/compound_dictionary.c',
-            'c/enc/compress_fragment.c',
-            'c/enc/compress_fragment_two_pass.c',
-            'c/enc/dictionary_hash.c',
-            'c/enc/encode.c',
-            'c/enc/encoder_dict.c',
-            'c/enc/entropy_encode.c',
-            'c/enc/fast_log.c',
-            'c/enc/histogram.c',
-            'c/enc/literal_cost.c',
-            'c/enc/memory.c',
-            'c/enc/metablock.c',
-            'c/enc/static_dict.c',
-            'c/enc/utf8_util.c',
-        ],
-        depends=[
-            'c/common/constants.h',
-            'c/common/context.h',
-            'c/common/dictionary.h',
-            'c/common/platform.h',
-            'c/common/shared_dictionary_internal.h',
-            'c/common/transform.h',
-            'c/common/version.h',
-            'c/dec/bit_reader.h',
-            'c/dec/huffman.h',
-            'c/dec/prefix.h',
-            'c/dec/state.h',
-            'c/enc/backward_references.h',
-            'c/enc/backward_references_hq.h',
-            'c/enc/backward_references_inc.h',
-            'c/enc/bit_cost.h',
-            'c/enc/bit_cost_inc.h',
-            'c/enc/block_encoder_inc.h',
-            'c/enc/block_splitter.h',
-            'c/enc/block_splitter_inc.h',
-            'c/enc/brotli_bit_stream.h',
-            'c/enc/cluster.h',
-            'c/enc/cluster_inc.h',
-            'c/enc/command.h',
-            'c/enc/compound_dictionary.h',
-            'c/enc/compress_fragment.h',
-            'c/enc/compress_fragment_two_pass.h',
-            'c/enc/dictionary_hash.h',
-            'c/enc/encoder_dict.h',
-            'c/enc/entropy_encode.h',
-            'c/enc/entropy_encode_static.h',
-            'c/enc/fast_log.h',
-            'c/enc/find_match_length.h',
-            'c/enc/hash.h',
-            'c/enc/hash_composite_inc.h',
-            'c/enc/hash_forgetful_chain_inc.h',
-            'c/enc/hash_longest_match64_inc.h',
-            'c/enc/hash_longest_match_inc.h',
-            'c/enc/hash_longest_match_quickly_inc.h',
-            'c/enc/hash_rolling_inc.h',
-            'c/enc/hash_to_binary_tree_inc.h',
-            'c/enc/histogram.h',
-            'c/enc/histogram_inc.h',
-            'c/enc/literal_cost.h',
-            'c/enc/memory.h',
-            'c/enc/metablock.h',
-            'c/enc/metablock_inc.h',
-            'c/enc/params.h',
-            'c/enc/prefix.h',
-            'c/enc/quality.h',
-            'c/enc/ringbuffer.h',
-            'c/enc/static_dict.h',
-            'c/enc/static_dict_lut.h',
-            'c/enc/utf8_util.h',
-            'c/enc/write_bits.h',
-        ],
-        include_dirs=[
-            'c/include',
-        ]),
-]
-
-TEST_SUITE = 'setup.get_test_suite'
-
-CMD_CLASS = {
-    'build_ext': BuildExt,
-}
-
-setup(
-    name=NAME,
-    description=DESCRIPTION,
-    version=VERSION,
-    url=URL,
-    author=AUTHOR,
-    license=LICENSE,
-    platforms=PLATFORMS,
-    classifiers=CLASSIFIERS,
-    package_dir=PACKAGE_DIR,
-    py_modules=PY_MODULES,
-    ext_modules=EXT_MODULES,
-    test_suite=TEST_SUITE,
-    cmdclass=CMD_CLASS)
+# receipe/brotli/setup_for_p4a.py
+# MODIFIED setup.py for use with p4a's source_subdir = 'python'
+# Original: google/brotli/python/setup.py
+
+import os
+import platform
+import re
+# unittest import is kept as BuildExt might reference it, but actual test suite execution is disabled.
+import unittest
+
+try:
+    from setuptools import Extension, find_packages # Import find_packages
+    from setuptools import setup
+except ImportError:
+    from distutils.core import Extension
+    from distutils.core import setup
+    # Basic fallback for find_packages if setuptools is truly unavailable (unlikely in p4a hostpython)
+    def find_packages(where='.'):
+        return [d for d in os.listdir(where) if os.path.isdir(os.path.join(where, d)) and os.path.exists(os.path.join(where, d, '__init__.py'))]
+
+from distutils.command.build_ext import build_ext
+from distutils import errors
+from distutils import dep_util
+from distutils import log
+
+
+# CURR_DIR will be the absolute path to the 'python' directory
+# when p4a runs this with source_subdir = 'python'
+CURR_DIR = os.path.abspath(os.path.dirname(os.path.realpath(__file__)))
+
+
+def read_define(path, macro):
+  """ Return macro value from the given file. """
+  with open(path, 'r', encoding='utf-8') as f: # Added encoding
+    for line in f:
+      m = re.match(rf'#define\s{macro}\s+(.+)', line)
+      if m:
+        return m.group(1)
+  return ''
+
+
+def get_version():
+  """ Return library version string from 'common/version.h' file. """
+  # Path adjustment: C sources are one level up from this script's location (python/)
+  version_file_path = os.path.join(CURR_DIR, os.path.pardir, 'c', 'common', 'version.h')
+  major = read_define(version_file_path, 'BROTLI_VERSION_MAJOR')
+  minor = read_define(version_file_path, 'BROTLI_VERSION_MINOR')
+  patch = read_define(version_file_path, 'BROTLI_VERSION_PATCH')
+  if not major or not minor or not patch:
+    # Fallback or error if version can't be read (e.g., if c/common/version.h is missing)
+    # For p4a, it's better to have a default if parsing fails, or let the build fail clearly.
+    # Here, we'll let it return empty, and setuptools might complain or use a default.
+    # A more robust recipe might pass the version via an environment variable.
+    log.warn("Could not read version from C header, Brotli version might be incorrect.")
+    return "0.0.0" # Fallback version
+  return f'{major}.{minor}.{patch}'
+
+
+class BuildExt(build_ext):
+  # This class is mostly unchanged from the original, it handles C extension building.
+  def get_source_files(self):
+    filenames = build_ext.get_source_files(self)
+    for ext in self.extensions:
+      if hasattr(ext, 'depends') and ext.depends: # Check if depends exists and is not None
+          filenames.extend(ext.depends)
+    return filenames
+
+  def build_extension(self, ext):
+    if ext.sources is None or not isinstance(ext.sources, (list, tuple)):
+      raise errors.DistutilsSetupError(
+        "in 'ext_modules' option (extension '%s'), "
+        "'sources' must be present and must be "
+        "a list of source filenames" % ext.name)
+    ext_path = self.get_ext_fullpath(ext.name)
+    # Ensure ext.depends is a list to avoid errors if it's None
+    depends = ext.sources + (ext.depends or [])
+    if not (self.force or dep_util.newer_group(depends, ext_path, 'newer')):
+      log.debug("skipping '%s' extension (up-to-date)", ext.name)
+      return
+    else:
+      log.info("building '%s' extension", ext.name)
+    c_sources = []
+    for source in ext.sources:
+      if source.endswith('.c'):
+        c_sources.append(source)
+    extra_args = ext.extra_compile_args or []
+    objects = []
+    macros = ext.define_macros[:]
+    if platform.system() == 'Darwin':
+      macros.append(('OS_MACOSX', '1'))
+    elif self.compiler.compiler_type == 'mingw32':
+      macros.append(('_hypot', 'hypot'))
+    for undef in ext.undef_macros:
+      macros.append((undef,))
+    # Ensure ext.depends is a list for compiler.compile
+    compile_depends = ext.depends or []
+    objs = self.compiler.compile(
+        c_sources,
+        output_dir=self.build_temp,
+        macros=macros,
+        include_dirs=ext.include_dirs,
+        debug=self.debug,
+        extra_postargs=extra_args,
+        depends=compile_depends) # Use compile_depends
+    objects.extend(objs)
+    self._built_objects = objects[:]
+    if ext.extra_objects:
+      objects.extend(ext.extra_objects)
+    extra_args = ext.extra_link_args or []
+    if self.compiler.compiler_type == 'mingw32':
+        extra_args.extend(['-static-libgcc', '-static-libstdc++'])
+    ext_path = self.get_ext_fullpath(ext.name)
+    language = ext.language or self.compiler.detect_language(c_sources)
+    self.compiler.link_shared_object(
+        objects,
+        ext_path,
+        libraries=self.get_libraries(ext),
+        library_dirs=ext.library_dirs,
+        runtime_library_dirs=ext.runtime_library_dirs,
+        extra_postargs=extra_args,
+        export_symbols=self.get_export_symbols(ext),
+        debug=self.debug,
+        build_temp=self.build_temp,
+        target_lang=language)
+
+# --- Metadata ---
+NAME = 'Brotli'
+VERSION = get_version() # Call the modified get_version
+URL = 'https://github.com/google/brotli'
+DESCRIPTION = 'Python bindings for the Brotli compression library'
+AUTHOR = 'The Brotli Authors'
+LICENSE = 'MIT'
+PLATFORMS = ['Posix', 'MacOS X', 'Windows']
+CLASSIFIERS = [
+    'Development Status :: 4 - Beta','Environment :: Console','Intended Audience :: Developers',
+    'License :: OSI Approved :: MIT License','Operating System :: MacOS :: MacOS X',
+    'Operating System :: Microsoft :: Windows','Operating System :: POSIX :: Linux',
+    'Programming Language :: C','Programming Language :: C++','Programming Language :: Python',
+    'Programming Language :: Python :: 2.7', # Original supports Py2
+    'Programming Language :: Python :: 3',
+    'Programming Language :: Python :: 3.6', 'Programming Language :: Python :: 3.7',
+    'Programming Language :: Python :: 3.8', 'Programming Language :: Python :: 3.9',
+    'Programming Language :: Python :: 3.10', 'Programming Language :: Python :: 3.11',
+    'Topic :: Software Development :: Libraries','Topic :: Software Development :: Libraries :: Python Modules',
+    'Topic :: System :: Archiving','Topic :: System :: Archiving :: Compression',
+]
+
+# --- Package and Extension Configuration (MODIFIED) ---
+
+# When this setup.py is run from the 'python' directory (due to p4a's source_subdir='python'),
+# the 'brotli' package (which is a directory named 'brotli' containing an __init__.py)
+# is located in the current working directory.
+# find_packages(where='.') will find this 'brotli' package.
+PACKAGES_TO_INSTALL = find_packages(where='.') # Correctly finds 'brotli' package in current (python/) dir
+PACKAGE_DIR_CONFIG = {} # Indicates packages are in the current directory relative to this setup.py
+
+EXT_MODULES = [
+    Extension(
+        # The resulting .so file will be _brotli.so, and importable as '._brotli' or similar
+        # depending on how the 'brotli' package imports it.
+        # Standard practice is for the 'brotli' package to import '_brotli'.
+        'brotli._brotli', # Build extension inside the 'brotli' package
+        sources=[
+            # Path to _brotli.c is relative to this setup.py (which is in python/)
+            # Assuming _brotli.c is directly in the 'python' directory alongside setup.py
+            '_brotli.c',
+            # Paths to C library sources are one level up (../c/)
+            os.path.join(os.path.pardir, 'c', 'common', 'constants.c'),
+            os.path.join(os.path.pardir, 'c', 'common', 'context.c'),
+            # ... (all other C source files from the original, prefixed with os.path.join(os.path.pardir, ...)) ...
+            os.path.join(os.path.pardir, 'c', 'common', 'dictionary.c'),
+            os.path.join(os.path.pardir, 'c', 'common', 'platform.c'),
+            os.path.join(os.path.pardir, 'c', 'common', 'shared_dictionary.c'),
+            os.path.join(os.path.pardir, 'c', 'common', 'transform.c'),
+            os.path.join(os.path.pardir, 'c', 'dec', 'bit_reader.c'),
+            os.path.join(os.path.pardir, 'c', 'dec', 'decode.c'),
+            os.path.join(os.path.pardir, 'c', 'dec', 'huffman.c'),
+            os.path.join(os.path.pardir, 'c', 'dec', 'state.c'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'backward_references.c'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'backward_references_hq.c'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'bit_cost.c'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'block_splitter.c'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'brotli_bit_stream.c'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'cluster.c'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'command.c'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'compound_dictionary.c'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'compress_fragment.c'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'compress_fragment_two_pass.c'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'dictionary_hash.c'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'encode.c'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'encoder_dict.c'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'entropy_encode.c'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'fast_log.c'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'histogram.c'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'literal_cost.c'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'memory.c'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'metablock.c'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'static_dict.c'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'utf8_util.c'),
+        ],
+        depends=[
+            # Paths to C header files are one level up (../c/)
+            os.path.join(os.path.pardir, 'c', 'common', 'constants.h'),
+            os.path.join(os.path.pardir, 'c', 'common', 'context.h'),
+            # ... (all other .h files from the original, prefixed with os.path.join(os.path.pardir, ...)) ...
+            os.path.join(os.path.pardir, 'c', 'common', 'dictionary.h'),
+            os.path.join(os.path.pardir, 'c', 'common', 'platform.h'),
+            os.path.join(os.path.pardir, 'c', 'common', 'shared_dictionary_internal.h'),
+            os.path.join(os.path.pardir, 'c', 'common', 'transform.h'),
+            os.path.join(os.path.pardir, 'c', 'common', 'version.h'),
+            os.path.join(os.path.pardir, 'c', 'dec', 'bit_reader.h'),
+            os.path.join(os.path.pardir, 'c', 'dec', 'huffman.h'),
+            os.path.join(os.path.pardir, 'c', 'dec', 'prefix.h'),
+            os.path.join(os.path.pardir, 'c', 'dec', 'state.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'backward_references.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'backward_references_hq.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'backward_references_inc.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'bit_cost.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'bit_cost_inc.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'block_encoder_inc.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'block_splitter.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'block_splitter_inc.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'brotli_bit_stream.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'cluster.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'cluster_inc.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'command.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'compound_dictionary.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'compress_fragment.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'compress_fragment_two_pass.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'dictionary_hash.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'encoder_dict.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'entropy_encode.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'entropy_encode_static.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'fast_log.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'find_match_length.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'hash.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'hash_composite_inc.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'hash_forgetful_chain_inc.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'hash_longest_match64_inc.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'hash_longest_match_inc.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'hash_longest_match_quickly_inc.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'hash_rolling_inc.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'hash_to_binary_tree_inc.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'histogram.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'histogram_inc.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'literal_cost.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'memory.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'metablock.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'metablock_inc.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'params.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'prefix.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'quality.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'ringbuffer.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'static_dict.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'static_dict_lut.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'utf8_util.h'),
+            os.path.join(os.path.pardir, 'c', 'enc', 'write_bits.h'),
+        ],
+        include_dirs=[
+            # Path to C include directory is one level up (../c/include)
+            os.path.join(os.path.pardir, 'c', 'include'),
+        ]),
+]
+
+# --- Test Suite (DISABLED) ---
+# TEST_SUITE_ADJUSTED = None # Explicitly set to None
+
+# --- Command Class ---
+CMD_CLASS = {
+    'build_ext': BuildExt,
+}
+
+# --- README ---
+# Read README.md relative to the original project root (one level up from python/)
+readme_path = os.path.join(CURR_DIR, os.path.pardir, "README.md")
+try:
+    with open(readme_path, "r", encoding="utf-8") as f:
+        README = f.read()
+except FileNotFoundError:
+    README = DESCRIPTION # Fallback if README.md is not found
+
+# --- Setup Call ---
+setup(
+    name=NAME,
+    description=DESCRIPTION,
+    long_description=README,
+    long_description_content_type="text/markdown",
+    version=VERSION,
+    url=URL,
+    author=AUTHOR,
+    license=LICENSE,
+    platforms=PLATFORMS,
+    classifiers=CLASSIFIERS,
+    package_dir=PACKAGE_DIR_CONFIG, # Use the adjusted package_dir
+    packages=PACKAGES_TO_INSTALL,   # Use packages to find the 'brotli' package
+    ext_modules=EXT_MODULES,
+    # test_suite=TEST_SUITE_ADJUSTED, # Set to None or remove entirely
+    cmdclass=CMD_CLASS
+)
\ No newline at end of file
